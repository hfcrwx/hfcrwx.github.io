---
title: "debug"
published: true
---

# Linux C/C++代码调试
## 前言

https://github.com/SimpleSoft-2020/book_debug.git

## 第1章　C/C++调试基本知识

### 1.1　BUG与Debug

发现问题的根源比想出解决方案更重要。找到问题的根源是一种技能，也更有价值。

### 1.2　为什么选择C/C++

本书主要介绍如何调试C/C++代码，如果掌握了本书的调试方法与技巧，其他语言的调试也能够驾轻就熟。

如果掌握了VC软件的调试方法与技巧，就可以轻松地迁移到Dev-C上进行调试，甚至能够平滑地迁移到Eclipse中调试Java代码—尽管界面有所不同，但是软件调试的核心是相同的。

## 第3章　Linux系统gdb调试基本功能

### 3.1　Linux C/C++编程基本知识

无论在哪里编写代码，最后都要到Linux系统中编译、调试和运行。

#### 3.1.1　开发环境安装

在Linux系统中开发C/C++程序时，我们用到的工具一般是gcc和g++。gcc和g++既有区别，又有联系，下面进行简单介绍。

GCC（GNU Compiler Collection）即GNU编译工具集，有编译器、链接器、组装器等，主要用来编译C和C++语言，也可以编译Objective-C和Objective-C++程序。注意，这里的GCC是大写的，代表的是GNU编译工具集。

而gcc（GNU C Compiler）（注意，这里是小写的）代表的是GNU C语言编译器；g++代表的是GNU C++语言编译器。但是从本质上讲，gcc和g++并不是真正的编译器，它们也只是GCC里面的两个工具，在编译C/C++程序时，它们会调用真正的编译器对代码进行编译。可以简单地这样理解：gcc工作的时候会调用C编译器；g++工作的时候会调用C++编译器。二者的部分区别如下。

**·文件后缀名的处理方式不同：**gcc会将后缀为.c的文件当作C程序，将后缀为.cpp的文件当作C++程序；g++会将后缀为.c和.cpp的都当成C++程序。因为C和C++语法上有一些区别，所以有时候通过g++编译的程序不一定能通过gcc编译。要注意的是，gcc和g++都可以用来编译C和C++代码。

**·链接方式不同：**gcc不会自动链接C++库（比如STL标准库），g++会自动链接C++库。

**·预处理器宏不同：**g++会自动添加一些预处理器宏，比如__cplusplus，但是gcc不会。所以，如果要开发纯C语言的程序，可以使用gcc；如果要开发C/C++程序，而且还要使用STL标准库。为了开发的便利性，建议使用g++。

**1.CentOS上安装gcc和g++**

```
yum -y install gcc gcc-c++
```

```
gcc -v
```

```
g++ -v
```

**2.在Ubuntu上安装gcc和g++**

```
apt-get -y install gcc g++
```

#### 3.1.2　开发第一个C/C++程序

**1.使用C语言编写HelloWorld程序**

helloworld.c

```c
#include <stdio.h>

int main() {
  printf("hello, world\n");
  return 0;
}

```

```
gcc -o helloworld helloworld.c
```

```
g++ -o helloworld helloworld.c
```

**2.使用C++语言编写HelloWorld程序**

helloworldplus.cpp

```c++
#include <iostream>

int main() {
  std::cout << "hello, world" << std::endl;
  return 0;
}

```

```
g++ -o helloworldplus helloworldplus.cpp
```

```
gcc -o helloworldplus helloworldplus.cpp -lstdc++
```

```
gcc -c helloworldpuls.cpp
```

**3.使用Makefile**

```
目标:依赖关系
	命令
	命令
```

注意，依赖关系和命令可以书写为一行，命令之间要用分号隔开。一般采用写为多行的方式，以便查看。写为多行时，命令前面的空白不是空格，而是按下Tab键形成的。

Makefile的目标文件命名为main.o、student.o，这与gcc编译结果的真实目标文件是一致的，但这不是必需的，目标文件可以任意命名，只要符合Makefile的命名规则即可

### 3.2　gdb简介

#### 3.2.1　gdb的安装

```
gdb -v
```

#### 3.2.2　gdb常用功能概览

| 支持的功能                | 描述                                               |
| ------------------------- | -------------------------------------------------- |
| 断点管理                  | 设置断点、查看断点等                               |
| 调试执行                  | 逐语句、逐过程执行                                 |
| 查看数据                  | 在调试状态下查看变量数据、内存数据等               |
| 运行时修改变量值          | 在调试状态下修改某个变量的值                       |
| 显示源代码                | 查看源代码信息                                     |
| 搜索源代码                | 对源代码进行查找                                   |
| 调用堆栈管理              | 查看堆栈信息                                       |
| 线程管理                  | 调试多线程程序，查看线程信息                       |
| 进程管理                  | 调试多个进程                                       |
| 崩溃转储（core dump）分析 | 分析 core dump 文件                                |
| 调试启动方式              | 用不同方式调试进程，比如加载参数启动、附加到进程等 |

### 3.3　调试执行

#### 3.3.1　启动调试

chapter_3.3

```
gdb chapter_3.3
```

```
[root@iZ2ze7qslbwa07f03lfmegZ chapter_3.3]# gdb chapter_3.3
GNU gdb (GDB) Red Hat Enterprise Linux 8.3-3.el7
Copyright (C) 2019 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from chapter_3.3...
(gdb) list
198			int throw_num = 50;
199			printf("throw\n");
200	                throw 10;
201	        }
202	        catch(...)
203	        {
204			int catch_num = 100;
205	                printf("catch ...\n");
206	        }
(gdb) r
Starting program: /root/book_debug/chapter_3.3/chapter_3.3 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib64/libthread_db.so.1".
name is test_try_catch,10
throw
catch ...
[New Thread 0x7ffff6efd700 (LWP 5852)]
线程函数开始
启动新线程：0
[New Thread 0x7ffff66fc700 (LWP 5853)]
线程函数开始
启动新线程：1
[New Thread 0x7ffff5efb700 (LWP 5854)]
线程函数开始
启动新线程：2
[New Thread 0x7ffff56fa700 (LWP 5855)]
线程函数开始
启动新线程：3
[New Thread 0x7ffff4ef9700 (LWP 5856)]
启动新线程：4
线程函数开始
[New Thread 0x7ffff46f8700 (LWP 5857)]
启动新线程：5
线程函数开始
[New Thread 0x7ffff3ef7700 (LWP 5858)]
线程函数开始
启动新线程：6
[New Thread 0x7ffff36f6700 (LWP 5859)]
线程函数开始
启动新线程：7
[New Thread 0x7ffff2ef5700 (LWP 5860)]
线程函数开始
启动新线程：8
[New Thread 0x7ffff26f4700 (LWP 5861)]
线程函数开始
启动新线程：9
线程函数结束
线程函数结束
[Thread 0x7ffff6efd700 (LWP 5852) exited]
[Thread 0x7ffff66fc700 (LWP 5853) exited]
线程函数结束
[Thread 0x7ffff5efb700 (LWP 5854) exited]
线程函数结束
[Thread 0x7ffff56fa700 (LWP 5855) exited]
线程函数结束
[Thread 0x7ffff4ef9700 (LWP 5856) exited]
线程函数结束
[Thread 0x7ffff46f8700 (LWP 5857) exited]
线程函数结束
[Thread 0x7ffff3ef7700 (LWP 5858) exited]
线程函数结束
[Thread 0x7ffff36f6700 (LWP 5859) exited]
线程函数结束
[Thread 0x7ffff2ef5700 (LWP 5860) exited]
线程函数结束
level is 1,str is call_fun_test_1,name is call_fun_test_1
level is 2,str is call_fun_test_2,name is call_fun_test_2
str is test,number is 305419896,node id is 100,test end
0 1 2 3 4 5 6 7 8 9 this is a test string arr test done
a is 10,x is 100,str is test
quit fun
execute test_fun_x
test fun x
execute test_fun_x
test fun x
execute test_fun_x
test fun x
execute test_fun_x
test fun x
execute test_fun_x
test fun x
execute test_fun_x
test fun x
execute test_fun_x
test fun x
execute test_fun_x
test fun x
execute test_fun_x
test fun x
execute test_fun_x
test fun x
i is 10
str is test
test_1 test_fun
test_2 test_fun
传入的参数信息为:
参数 0=/root/book_debug/chapter_3.3/chapter_3.3
会员管理系统
1:录入会员信息
q:退出
[Thread 0x7ffff26f4700 (LWP 5861) exited]
q
[Inferior 1 (process 5848) exited normally]
(gdb) q
[root@iZ2ze7qslbwa07f03lfmegZ chapter_3.3]#
```

问题

```
Missing separate debuginfos, use: debuginfo-install glibc-2.17-325.el7_9.x86_64
```

解决

```
// yum install glibc-2.17-325.el7_9.x86_64
yum install yum-utils
debuginfo-install glibc-2.17-325.el7_9.x86_64
```

问题

```
[root@iZ2ze7qslbwa07f03lfmehZ ~]# debuginfo-install glibc-2.17-325.el7_9.x86_64
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
Could not find debuginfo for main pkg: glibc-2.17-325.el7_9.x86_64
Could not find debuginfo pkg for dependency package nss-softokn-freebl-3.67.0-3.el7_9.x86_64
No debuginfo packages available to install
```

解决

创建 /etc/yum.repos.d/CentOS-Debuginfo.repo

```
# CentOS-Debug.repo
#
# The mirror system uses the connecting IP address of the client and the
# update status of each mirror to pick mirrors that are updated to and
# geographically close to the client.  You should use this for CentOS updates
# unless you are manually picking other mirrors.
#

# All debug packages from all the various CentOS-7 releases
# are merged into a single repo, split by BaseArch
#
# Note: packages in the debuginfo repo are currently not signed
#

[base-debuginfo]
name=CentOS-7 - Debuginfo
baseurl=http://debuginfo.centos.org/7/$basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-Debug-7
enabled=1
#
```

```
yum clean all
yum makecache
```

```
debuginfo-install glibc-2.17-325.el7_9.x86_64
```

问题

```
warning: File "/usr/local/lib64/libstdc++.so.6.0.26-gdb.py" auto-loading has been declined by your `auto-load safe-path' set to "$debugdir:$datadir/auto-load:/usr/share/gdb/auto-load".
To enable execution of this file add
	add-auto-load-safe-path /usr/local/lib64/libstdc++.so.6.0.26-gdb.py
line to your configuration file "/root/.gdbinit".
To completely disable this security protection add
	set auto-load safe-path /
line to your configuration file "/root/.gdbinit".
For more information about this security protection see the
"Auto-loading safe path" section in the GDB manual.  E.g., run from the shell:
	info "(gdb)Auto-loading safe path"
```

解决

/root/.gdbinit

```
add-auto-load-safe-path /usr/local/lib64/libstdc++.so.6.0.26-gdb.py
```

#### 3.3.2　启动调试并添加参数

```
gdb chapter_3.3
set args admin passwd
r
```

#### 3.3.3　附加到进程

```
/chapter_3.3
```

```
[root@iZ2ze7qslbwa07f03lfmegZ chapter_3.3]# ps aux | grep chapter_3.3
root      6170  0.0  0.0  48564  1764 pts/2    S+   16:06   0:00 ./chapter_3.3
root      6238  0.0  0.0 112816   996 pts/0    S+   16:08   0:00 grep --color=auto chapter_3.3
[root@iZ2ze7qslbwa07f03lfmegZ chapter_3.3]# gdb attach 6170
```

此时，可以在gdb中输入gdb相关的命令，比如设置断点等。此时整个chapter_3.3程序处于暂停状态，需要在gdb中输入命令c继续运行，程序才能恢复为正常状态。我们在gdb中输入c，使程序继续运行。然后在chapter_3.3窗口输入q退出程序，此时，gdb也能检测到程序已经退出。然后在gdb窗口输入q，退出gdb调试。

### 3.4　断点管理

#### 3.4.1　设置断点

普通断点、条件断点、数据断点

**1.在源代码的某一行设置断点**

```
break 文件名:行号
```

```
break chapter_3.3.cpp:49
run
list
print
```

